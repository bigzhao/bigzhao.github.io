<?xml version="1.0" encoding="utf-8"?><feed xmlns="http://www.w3.org/2005/Atom" ><generator uri="https://jekyllrb.com/" version="3.4.3">Jekyll</generator><link href="http://localhost:4000/feed.xml" rel="self" type="application/atom+xml" /><link href="http://localhost:4000/" rel="alternate" type="text/html" /><updated>2017-05-03T16:13:04+08:00</updated><id>http://localhost:4000/</id><title type="html">Bigzhao Blog</title><subtitle>C++ Python 前段 算法 演化算法 | 深大信工 -&gt; 华工计算机 | 这里是 @Bigzhao大招 的个人博客，与你一起发现更大的世界。</subtitle><entry><title type="html">ubuntu 离线安装makefile</title><link href="http://localhost:4000/2017/04/29/ubuntu-%E7%A6%BB%E7%BA%BF%E5%AE%89%E8%A3%85makefile/" rel="alternate" type="text/html" title="ubuntu 离线安装makefile" /><published>2017-04-29T20:00:00+08:00</published><updated>2017-04-29T20:00:00+08:00</updated><id>http://localhost:4000/2017/04/29/ubuntu-%E7%A6%BB%E7%BA%BF%E5%AE%89%E8%A3%85makefile</id><content type="html" xml:base="http://localhost:4000/2017/04/29/ubuntu-%E7%A6%BB%E7%BA%BF%E5%AE%89%E8%A3%85makefile/">&lt;h2 id=&quot;ubuntu-离线安装makefile&quot;&gt;ubuntu 离线安装makefile&lt;/h2&gt;
&lt;ol&gt;
  &lt;li&gt;到&lt;a href=&quot;&quot;&gt;http://ftp.gnu.org/gnu/make/&lt;/a&gt; 下载make 安装包 我下的是make-3.81.tar.gz&lt;/li&gt;
  &lt;li&gt;复制到机器上，解压并进入目录
    &lt;div class=&quot;language-sh highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;tar -xzvf make-3.81.tar.gz
&lt;span class=&quot;nb&quot;&gt;cd &lt;/span&gt;make-3.81
&lt;/code&gt;&lt;/pre&gt;
    &lt;/div&gt;
  &lt;/li&gt;
  &lt;li&gt;依次执行以下命令
    &lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;./configure
./make check
./make install
./make clean
&lt;/code&gt;&lt;/pre&gt;
    &lt;/div&gt;
  &lt;/li&gt;
  &lt;li&gt;完成&lt;/li&gt;
&lt;/ol&gt;</content><author><name>Bigzhao</name></author><summary type="html">ubuntu 离线安装makefile 到http://ftp.gnu.org/gnu/make/ 下载make 安装包 我下的是make-3.81.tar.gz 复制到机器上，解压并进入目录 tar -xzvf make-3.81.tar.gz cd make-3.81 依次执行以下命令 ./configure ./make check ./make install ./make clean 完成</summary></entry><entry><title type="html">多峰分布估计算法 文献翻译</title><link href="http://localhost:4000/2017/04/20/MEDA/" rel="alternate" type="text/html" title="多峰分布估计算法  文献翻译" /><published>2017-04-20T20:00:00+08:00</published><updated>2017-04-20T20:00:00+08:00</updated><id>http://localhost:4000/2017/04/20/MEDA</id><content type="html" xml:base="http://localhost:4000/2017/04/20/MEDA/">&lt;h1 id=&quot;多峰分布估计算法-multimodal-estimation-of-distribution-algorithms&quot;&gt;多峰分布估计算法 Multimodal Estimation of Distribution Algorithms&lt;/h1&gt;
&lt;h2 id=&quot;引言&quot;&gt;引言&lt;/h2&gt;
&lt;p&gt;多峰优化，即旨在同时找出多个最优解，在近些年来越来越受到研究人员的重视。在现实生活中诸如蛋白质结构预测、电路设计、数据挖掘等实际应用都需要算法同时找出多个最优解。与普通的最优化问题不同，多峰优化问题中多个最优解的同时定位更具挑战性。&lt;/p&gt;

&lt;p&gt;由于多峰优化问题的特殊性，传统的进化算法不能够直接用于解决该问题。原因在于进化算法倾向于将整个种群收敛于一个全局最优解上，因此不能定位到其他符合条件的最优解。为了解决此缺陷，研究人员提出了划分小生境(niching)这一辅助策略来帮助进化算法解决多峰问题。一般来说，划分小生境的做法是将整个种群划分为若干小生境，小生境包含一个小种群，每个小生境的子种群负责找出问题的一个或多个最优解。&lt;/p&gt;

&lt;p&gt;近些年来，有学者提出了一种新的进化算法——分布估计算法（Estimation of Distribution Algorithms），该算法很好地维持了种群层面的多样性。一般来说，分布估计算法按照种群中优秀的个体概率分布统计来随机产生后代。然而，目前的分布估计算法多被用来解决最优化问题。到目前为止，文献中仍没有关于运用分布估计算法来处理多峰优化问题的文献出现。&lt;/p&gt;

&lt;p&gt;由于分布估计算法能够很好地维持种群的高多样性，因此用其来解决多峰优化问题应是可行的。沿着上述研究方向，我们提出了一个改良的针对多峰优化问题的分布估计算法，称之为多峰分布估计算法（Multimodal Estimation of Distribution Algorithms，MEDA）。本研究提出的多峰分布估计算法有如下4个特征：&lt;/p&gt;
&lt;ol&gt;
  &lt;li&gt;MEDA可运用“crowding”或“speciation”两种划分策略来划分小生境，根据选用策略不同可将MEDA细分为MCEDA或MSEDA。与传统EDA不同，MEDAs(MCEDA、MSEDA)在小生境的子种群层面上进行操作。此外，另一个与传统EDA算法的不同点是，每一个小生境的个体都参与了所属小生境的分布估计。&lt;/li&gt;
  &lt;li&gt;本研究提出了一种动态调整小生境规模的策略。通过结合小生境划分策略，平衡算法的探索能力(exploration)和开发能力(exploitation)，而且还降低了小生境对子种群的个体数的敏感性。&lt;/li&gt;
  &lt;li&gt;本研究结合高斯分布和柯西分布来产生小生境的后代。与传统EDA单独采用高斯分布产生后代不同，结合两种分布的优点在于此举能够更好地平衡算法的探索能力(exploration)和开发能力(exploitation)。&lt;/li&gt;
  &lt;li&gt;一个基于高斯分布的局部搜索策略将会被用来增加获得的最优解的质量。值得注意的是，该局部搜索只会有概率地在小生境的最优个体上进行，进行局部搜索的概率取决于这些最优个体的适应度。&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;本文剩余的章节安排如下，第二部分简要地回顾了多峰优化及分布估计算法，第三部分详细描述了本研究提出的多峰优化算法（MEDA）。在文章的最后，我们对本文进行了总结。&lt;/p&gt;
&lt;h2 id=&quot;二多峰优化及分布估计算法&quot;&gt;二、多峰优化及分布估计算法&lt;/h2&gt;
&lt;h3 id=&quot;a-多峰优化算法&quot;&gt;A. 多峰优化算法&lt;/h3&gt;
&lt;p&gt;一般地，为了有效地处理多峰优化问题，以下两个关键点首先需要被解决：&lt;/p&gt;
&lt;ul&gt;
  &lt;li&gt;diversification&lt;/li&gt;
  &lt;li&gt;intensification&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;为了解决上述两个关键点，不同的划分小生境策略已经被提出并且也已经结合进化算法来处理多峰问题。目前，“crowding”和“speciation”是最被人广泛使用的两个划分策略。&lt;/p&gt;

&lt;p&gt;虽然“crowding”和“speciation”策略具备良好的有效性及较高的划分效率，但是上述两个策略皆存在以下两个不足之处。第一，划分的性能很大程度上取决于其参数的选择。第二，以上策略不适用于复杂大规模的多峰优化问题。上述两个缺陷是“crowding”和“speciation”策略不能广泛应用在实际问题上的主要原因。&lt;/p&gt;

&lt;p&gt;为了减少划分策略对参数的敏感度，有学者提出基于拓补结构的划分策略。例如，Ursem 等人提出“hill-valley”方法，即通过测量两个抽样个体之间的适应度的“地形”来划分小生境。假如存在第三个点，其适应度均低于两个抽样点的适应度，则这意味着算法发现了一个“山谷”，因此“山谷”两边的个体应该归到两个不同的小生境中去。
虽然上述方法有能力自适应地决定小生境的数量，但是其不足之处在于其需要耗费大量额外的适应度评估次数。为了解决此问题，Li和tang等人提出了“history-based topo-logical speciation method”，其方法在找“山谷”时不需要检测的适应度评估次数。但是，他们的方法不保证找到所有的“山谷”。为了改善划分的效果，Gao等人和Qu等人运用聚类策略来划分小生境。&lt;/p&gt;

&lt;p&gt;随后，正如上文所述，许多结合小生境的改进的进化算法被用来解决多峰问题。然而，目前所有针对多峰优化问题的进化算法都是基于DE、GA或者PSO算法，并且这些算法都存在一定缺陷，例如不适用于大规模问题、不能处理具备很多局部最优解的问题等。此外，尽管EDA能够很好地维持种群的高度多样性，但是目前并没有研究人员将EDA用于多峰优化问题。&lt;/p&gt;
&lt;h3 id=&quot;b分布估计算法&quot;&gt;B．分布估计算法&lt;/h3&gt;
&lt;p&gt;通过概率分布来产生后代的分布估计算法（EDA）已经在最优化问题上被研究的较为透彻。其伪代码如下所示：&lt;/p&gt;
&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;Algorithm 1 EDA
Input: population size NP, the number of selected individuals K
1: Randomly initialize the population;
2: While the termination criteria is not satisfied
3:     Select K best individuals from the population;
4:     Estimate the probability distribution of the population according to the selected individuals;
5:     Sample new individuals according to the estimated distribution;
6:     Combine the sampled individuals and the old population to create a new population with NP individuals;
7: End While
Output: the best individual and its fitness
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;
&lt;p&gt;分布估计算法在处理连续优化问题和组合优化问题都已经获得了较大的成功，但是这些算法均为针对于最优化问题，目前基本上没有一个分布估计算法能够处理多峰优化问题。
抓住分布估计算法能够保持种群的高度多样性这一优点，本研究提出多峰优化算法MEDA来处理多峰优化问题。&lt;/p&gt;
&lt;h2 id=&quot;三多峰优化算法&quot;&gt;三、多峰优化算法&lt;/h2&gt;
&lt;p&gt;从Algorithm 1我们可以看出，传统的分布估计算法不能处理多峰问题。为了解决此问题，我们将分布估计算法与小生境策略相结合，构成一个全新的多峰优化算法MEDA。特别地，根据采取的划分策略的不同（crowding或者speciation），我们可以得到两个不同版本的MEDA，分别称之为MCEDA和MSEDA。为了平衡算法的探索性和局部开发性，MEDA运用动态的小生境大小来划分小生境。同时，为了更好地维持小生境的多样性，算法将会结合高斯分布及柯西分布来产生小生境的后代。此外，算法采用基于高斯分布的局部搜索策略辅助小生境进化，以提高获得的解的精度。&lt;/p&gt;
&lt;h3 id=&quot;a动态小生境大小&quot;&gt;A．动态小生境大小&lt;/h3&gt;
&lt;p&gt;一般地，给定种群大小，小生境的个体数越少，整体小生境的数目则越大，这对于全局探索十分有利，但是此举可能会导致每个小生境的多样性较低，导致最终得到的最优解质量不高、容易陷入小生境的局部最优等问题的出现。相反地，假如小生境中个体数越大，小生境的数量越小，尽管小生境的种群多样性增大，但是相应地算法的探测能力也随之降低。因此，为了平衡算法的探索能力和局部开发能力，本研究提出了一种能够动态调节小生境大小的策略。具体来说，当种群获得的有希望存在最优解的区域数目较少时，小生境的尺寸就随之增加以增加其种群多样性，即通过增强小生境的局部开发能力从而得到精度更高的解。相反地，当潜在的存在最优解的区域的数量较多时，小生境的大小将随之减少，以更好地搜索最优区域。由于缺乏对优化问题的先验知识，本研究在该策略上做了一个妥协，即每一次划分时都从候选集合里面随机挑选小生境的大小，这样能够在一定程度上平衡算法的探索能力和局部开发能力。
通过上述策略，MEDA打破小生境大小的限制，从而提供更高的多样性，同时平衡算法的探索能力和局部开发能力，也降低了算法对参数设置的敏感性。&lt;/p&gt;
&lt;h3 id=&quot;b-分布估计及产生后代&quot;&gt;B. 分布估计及产生后代&lt;/h3&gt;

&lt;p&gt;待种群划分为小生境后，MEDA便开始统计每个小生境的个体的概率分布。首先，与传统EDA不同的是，MEDA在小生境的层次上对所有个体进行分布统计，因为小生境的个体数不会很高，因此小生境里的每个个体都是有潜在意义的，因此都应参与其中。&lt;/p&gt;

&lt;p&gt;文献中存在许多分布模型，例如单一变量的高斯分布、多变量的高斯分布、直方图模型等等。一般来说，任意统计模型皆可应用于MEDA。本研究为了简明起见，采用了单变量的高斯分布，因为其具有较低的计算复杂度。因此，每个小生境的高斯分布可以独立地按下面的公式进行统计：
&lt;img src=&quot;http://o6gcipdzi.bkt.clouddn.com/gaosi.png&quot; alt=&quot;formular&quot; /&gt;	                       	                                            &lt;br /&gt;
其中 μi 和 δi 分别是种群里第i个小生境的平均值和方差向量。
	待分布统计完成后，小生境即可根据分布统计的结构来产生后代。大部分传统的EDA算法都使用高斯分布来采样点以产生后代，然而，由于高斯分布的采样空间通常比较窄，仅采用高斯分布产生后代会降低算法的探索性能。为了克服这一点，本研究将注意力转移到采样空间更广的柯西分布上。结合柯西分布，EDA不容易陷入局部最优。
	综上所述，我们发现高斯分布更适用于开发阶段，而凭借着较宽的采样空间，柯西分布更加适合于算法的探索阶段。这也促使本研究交替使用这上述两个分布来为小生境产生后代。MEDA的后代产生阶段在小生境的层次上进行，也就是说每个小生境随机选择其中一个分布模型来产生各自的后代。为了简单起见，小生境选择两个分布模型产生后代的概率相同。&lt;/p&gt;

&lt;p&gt;当各个小生境都成功产生各自后代之后，接下来要进行的步骤为个体筛选。本研究直接采用CDE的筛选策略，具体做法为：将小生境的每个后代与距其最相近（欧氏距离最短）的父代个体相比较，留下两者中适应度较高的个体。&lt;/p&gt;
&lt;h3 id=&quot;c局部搜索&quot;&gt;C．局部搜索&lt;/h3&gt;
&lt;p&gt;一般来说，分布估计算法 （EDA）具备强大的全局探索能力，但是相应地缺乏局部开发能力，故不能很好地改善解的精度。为了解决该缺陷，研究人员通过为EDA引入局部搜索技术以提高其局部开发能力。MEDA采用基于高斯分布的局部搜索技术。采用高斯分布的原因是，高斯分布拥有较窄的采样空间，而当高斯分布的标准偏差σ越小时，其采样空间也就越窄，因此采取一个较小的标准差σ将有利于局部开发。因此，基于高斯分布的局部搜索的标准差的值通常较小。特别地，本研究将σ的值设为1.0E-4。此外，局部搜索将只会在每个小生境最优秀的个体上进行。&lt;/p&gt;

&lt;p&gt;一般地，局部搜索可以表现为如下形式：
  	                          (3)&lt;/p&gt;

&lt;p&gt;其中  是局部搜索过程中生成的N个新解，N是预先定义好的新解的数量。特别地，本研究将N设为5。S_i代表着第i个小生境的最优秀个体。如上所属，局部搜索的结果取决于各个小生境的最优个体。&lt;/p&gt;

&lt;p&gt;总体上看，局部搜索的伪代码总结如下：&lt;/p&gt;
&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;Algorithm 2  Local Search
Input: seeds set S, the number of seeds s, fitness of these seeds F, local std value σ, the number of sampled individuals N
1: F_min= min(F), F_max = max(F), flag = false;
2: If F_min ≤ 0
3:   F_max = F_max + |F_min| + ξ;
4:   flag = true;
5: End If
//Calculate the probability for each seed to perform local search
6: For i = 1:s
7:   If flag
8:     Pr[i] = (F[i]+ |F_min|+ξ)/ F_max;
9:   else
10:    Pr[i] = F[i]/ F_max;
11:  End If
12: End For
13: For i = 1:s
14:   If rand( ) ≤ Pr[i]
15:     For j = 1:N
16:       Generate a new individual 〖 LC 〗_jusing Gaussian(S[i], σ);
17:       If〖 LC 〗_jis better than S[i]
18:         Replace S[i] with〖 LC 〗_j;
19:       End If
20:     End For
21:   End If
22: End For
Output: Seeds S and their fitness F
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;
&lt;h2 id=&quot;四结论&quot;&gt;四、结论&lt;/h2&gt;
&lt;p&gt;针对多峰优化问题，本研究提出多峰分布估计算法MEDA来定位多个全局最优解。该算法有效地将分布估计算法与划分小生境结合，能够获得令人满意的效果。该算法对多峰优化问题的优越性能源于本研究提出的三种技术：&lt;/p&gt;
&lt;ol&gt;
  &lt;li&gt;动态小生境大小&lt;/li&gt;
  &lt;li&gt;轮流使用两个分布模型来产生后代&lt;/li&gt;
  &lt;li&gt;围绕小生境最优个体的局部搜索策略&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;具体而言，动态调整小生境的大小能有效地平衡算法的探索能力及开发能力，并且也降低了MEDA对小生境大小的敏感性。此外，与传统分布估计算法（EDA）不同，在统计分布阶段中，MEDA在小生境层面上对个体进行分布估计，并且每个小生境的所有个体都参与了该小生境分布的估计。另外，MEDA随机采用高斯分布和柯西分布来产生小生境后代，由于高斯分布更适用于开发阶段而柯西分布则更擅长于探测，因此此举能很好地平衡算法的探索能力及开发能力。最后，通过基于高斯分布的局部搜索策略，算法能够根据不同小生境的最优个体进行局部搜索以提高最优解的精度。&lt;/p&gt;</content><author><name>Bigzhao</name></author><summary type="html">多峰分布估计算法 Multimodal Estimation of Distribution Algorithms 引言 多峰优化，即旨在同时找出多个最优解，在近些年来越来越受到研究人员的重视。在现实生活中诸如蛋白质结构预测、电路设计、数据挖掘等实际应用都需要算法同时找出多个最优解。与普通的最优化问题不同，多峰优化问题中多个最优解的同时定位更具挑战性。</summary></entry><entry><title type="html">深入理解操作系统笔记</title><link href="http://localhost:4000/2017/03/10/note/" rel="alternate" type="text/html" title="深入理解操作系统笔记" /><published>2017-03-10T20:00:00+08:00</published><updated>2017-03-10T20:00:00+08:00</updated><id>http://localhost:4000/2017/03/10/note</id><content type="html" xml:base="http://localhost:4000/2017/03/10/note/">&lt;h2 id=&quot;chapter-1&quot;&gt;chapter 1&lt;/h2&gt;
&lt;ul&gt;
  &lt;li&gt;&lt;strong&gt;计算机组成的五大部件&lt;/strong&gt;：运算器、控制器、存储器、输入设备、输出设备&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&quot;chapter-2&quot;&gt;chapter 2&lt;/h2&gt;
&lt;ul&gt;
  &lt;li&gt;浮点数表示形式 V = (-1)^s * M * 2^E&lt;/li&gt;
  &lt;li&gt;浮点数分为三部分 符号位(最高位) 尾数M（小数） 阶码2^E&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&quot;chapter-3&quot;&gt;chapter 3&lt;/h2&gt;
&lt;ul&gt;
  &lt;li&gt;程序寄存器组是唯一能被所有过程共享的资源&lt;/li&gt;
  &lt;li&gt;寄存器%eax, %edx, %ecx 为调用者保护寄存器caller-save，被调用者可以覆盖；寄存器%ebx,%esi,%edi 为被调用者保护寄存器callee-save，覆盖前要先保存到栈里面，退出时恢复&lt;/li&gt;
  &lt;li&gt;一个联合 UNION 的总大小等于它最大字段的大小&lt;/li&gt;
  &lt;li&gt;数据对齐，对于microsoft windows 系统K字节大小的类型的地址必须是K倍的,例如double的地址一定是8（linux一般为4）&lt;/li&gt;
  &lt;li&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;int (*fp) (int, int);&lt;/code&gt; 这是一个函数指针，指向一个返回值int 参数为两个int 类型的函数&lt;/li&gt;
  &lt;li&gt;在学习的过程中很明显表示了局部变量是存放在栈上的（回忆：8(%ebp),4(%ebp)）&lt;/li&gt;
  &lt;li&gt;堆：高地址扩展（与内存一致） 栈：低地址扩展&lt;/li&gt;
  &lt;li&gt;由汇编代码也可以知道，栈的大小是固定的，是提前减的(&lt;code class=&quot;highlighter-rouge&quot;&gt;sub $20, %esp&lt;/code&gt;)&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&quot;chapter-5&quot;&gt;chapter 5&lt;/h2&gt;
&lt;ul&gt;
  &lt;li&gt;消除循环的低效率 将不变的函数结果提取出来存放在变量里 免得重复调用&lt;/li&gt;
  &lt;li&gt;减少过程调用(函数)&lt;/li&gt;
  &lt;li&gt;消除不必要的存储器引用(例如结果存放在寄存器里面最后再放到存储器 ps:指针是指向存储器的)&lt;/li&gt;
  &lt;li&gt;衡量功能单位的两个指标
    &lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;1. 延迟(latency): 表示完成运算的总时间
2. 发射时间(issue time): 两个连续的同类型运算的间隔时钟周期（除法需要依赖数据值）
&lt;/code&gt;&lt;/pre&gt;
    &lt;/div&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&quot;chapter-6&quot;&gt;chapter 6&lt;/h2&gt;
&lt;ul&gt;
  &lt;li&gt;&lt;strong&gt;存储器系统&lt;/strong&gt;：cpu寄存器 高速缓存存储器（important 作为CPU和主存的桥梁） 主存储器 磁盘等外存&lt;/li&gt;
  &lt;li&gt;一般来说 静态RAM用来做高速缓存 动态RAM用来做主存&lt;/li&gt;
  &lt;li&gt;双列直插存储器模块DIMM(128引脚64位) 单列直插存储器模块SIMM(72引脚32位)&lt;/li&gt;
  &lt;li&gt;断电了RAM就会丢失信息（易失性）&lt;/li&gt;
  &lt;li&gt;非易失性存储器：ROM PROM(只能一次) EPROM(可擦除) EEPROM(电子可擦除) 闪存(基于EEPROM)&lt;/li&gt;
  &lt;li&gt;总线事务
    &lt;ol&gt;
      &lt;li&gt;读事物：从主存传送数据到CPU&lt;/li&gt;
      &lt;li&gt;写事务：从CPU传送数据到主存
&lt;img src=&quot;http://o6gcipdzi.bkt.clouddn.com/%E6%80%BB%E7%BA%BF.png&quot; alt=&quot;image&quot; /&gt;&lt;/li&gt;
    &lt;/ol&gt;
  &lt;/li&gt;
  &lt;li&gt;磁盘是由盘片构成的，盘片有两面（surface）表面覆盖着磁性材料，中间有转轴（主轴）可旋转 磁盘通常包括一个或者多个这样的磁片 并封装在一个密封的容器里
&lt;img src=&quot;http://pic002.cnblogs.com/images/2012/295881/2012052117213095.gif&quot; alt=&quot;image&quot; /&gt;
&lt;img src=&quot;http://pic002.cnblogs.com/images/2012/295881/2012052117224297.gif&quot; alt=&quot;&quot; /&gt;&lt;/li&gt;
  &lt;li&gt;存储容量 ＝ 磁头数 × 磁道(柱面)数 × 每道扇区数 × 每扇区字节数&lt;/li&gt;
  &lt;li&gt;寻道：通过移动传送臂来读写任意磁道&lt;/li&gt;
  &lt;li&gt;扇区的访问时间 = 寻道时间（3——9ms长） + 旋转时间 （找第一个字节 长） + 传送时间（读取扇区数据 短）&lt;/li&gt;
  &lt;li&gt;（盘面，磁道，扇区）-&amp;gt; 物理扇区&lt;/li&gt;
  &lt;li&gt;使用前一定要格式化 标记扇区间隔等信息 找出出错的柱面并不去使用它 预留出备用的扇区 故格式化后的空间比最大空间要小&lt;/li&gt;
  &lt;li&gt;DMA 直接传送 主存与磁盘&lt;/li&gt;
  &lt;li&gt;SSD = 闪存芯片+闪存翻译层 （页：512~4KB 块：32~128页 16~512KB） 数据以页为单位进行读写 写页之前要先擦出（所有位置1）块擦出后不需要进行页擦出 100000次后块磨损报废&lt;/li&gt;
  &lt;li&gt;局部性（locality）：程序倾向于引用最近引用过的数据或者相邻的数据
    &lt;ol&gt;
      &lt;li&gt;时间局部性：使用后在不久的时间内再次使用&lt;/li&gt;
      &lt;li&gt;空间局部性：在使用过的的存储器位置的附近的存储器位置&lt;/li&gt;
    &lt;/ol&gt;
  &lt;/li&gt;
  &lt;li&gt;位于k层更快更小的存储设备作为k+1层的缓存&lt;/li&gt;
  &lt;li&gt;缓存命中：当寻找k+1层的块d时，在k层的缓存中找到则称为缓存命中&lt;/li&gt;
  &lt;li&gt;缓存不命中：k层找不到去k+1层找，然后放到k层中等待访问&lt;/li&gt;
  &lt;li&gt;高速缓存用中间位做索引位 习题中证实用高位做索引为不能充分利用高速缓存块的空间局部性&lt;/li&gt;
  &lt;li&gt;组相联高速缓存：每组多行&lt;/li&gt;
  &lt;li&gt;全相联高速缓存：只有一组 例子:TLB&lt;/li&gt;
  &lt;li&gt;写的两种方式：1.直写：马上从缓存写到存储器里面 2.写回：推迟写操作指导块被替换（需要额外一个修改状态标志位 dirty bit）&lt;/li&gt;
  &lt;li&gt;i-cache d-cache unified-cache
&lt;img src=&quot;http://o6gcipdzi.bkt.clouddn.com/corei7.png&quot; alt=&quot;image&quot; /&gt;&lt;/li&gt;
  &lt;li&gt;因为一行总是存储一个块所以有时候两者概念会混着用&lt;/li&gt;
  &lt;li&gt;读吞吐量（读带宽） 1s读n字节 n/s 一般单位为MB/s&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&quot;chapter-7&quot;&gt;chapter 7&lt;/h2&gt;
&lt;ul&gt;
  &lt;li&gt;链接器的两个主要任务是符号解析（全局资源的唯一绑定）和地址的重定位&lt;/li&gt;
  &lt;li&gt;static 标记的函数和变量都是模块私有的&lt;/li&gt;
  &lt;li&gt;节：.text 存放编译好的机器代码（函数） .data： 全局及static .bss：只声明没赋值的变量或函数 省空间&lt;/li&gt;
  &lt;li&gt;变量或者函数在链接器里有唯一的名字对应&lt;/li&gt;
  &lt;li&gt;c++/java 允许重载怎么做到 用了编码 比如Foo::bar(int, long);-&amp;gt;bar_Fooil&lt;/li&gt;
  &lt;li&gt;强符号：函数和已经初始化的全局变量 弱符号：未初始化的全局变量&lt;/li&gt;
  &lt;li&gt;规则：
    &lt;ol&gt;
      &lt;li&gt;不允许多个强符号&lt;/li&gt;
      &lt;li&gt;如果有一个强符号和多个弱符号，则选择强符号&lt;/li&gt;
      &lt;li&gt;如果有多个弱符号，那么在这些弱符号中选择一个&lt;/li&gt;
    &lt;/ol&gt;
  &lt;/li&gt;
  &lt;li&gt;利用AR工具可以打包成库 静态库
    &lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;gcc -c addvec.c mulvec.c
ar rcs libvector.a addvec.o mulvec.o
&lt;/code&gt;&lt;/pre&gt;
    &lt;/div&gt;
  &lt;/li&gt;
  &lt;li&gt;链接的顺序是假如a调用了b，则b要放在a的后面，因为a要先挖坑 b再去填坑&lt;/li&gt;
  &lt;li&gt;目标文件.o 直接修改U(引用还没定义)+D(已定义) .a则需按照U来填坑&lt;/li&gt;
  &lt;li&gt;重定位 当引用了的库的时候地址可能会变化 需要地址的重定义 例如call&lt;/li&gt;
  &lt;li&gt;linux 代码段总是从0x08048000开始 数据段是从下一个4KB地址对齐处 并通过malloc向上增长（向高地址增长）&lt;/li&gt;
  &lt;li&gt;每个程序都有一个main的原因？因为C语言的启动程序会跳到一个叫main的函数上&lt;/li&gt;
  &lt;li&gt;共享库.so的主要目的是允许多个正在运行的进程共享存储器中相同的库代码，节约宝贵的存储器资源
    &lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;gcc -share -fPIC -o libvector.so addvec.c mulvec.c
gcc -o -02 p2 main.c ./libvector.so
&lt;/code&gt;&lt;/pre&gt;
    &lt;/div&gt;
  &lt;/li&gt;
  &lt;li&gt;PIC 位置独立的代码&lt;/li&gt;
  &lt;li&gt;在windows中静态库是以 .lib 为后缀的文件，共享库是以 .dll 为后缀的文件。在Linux中静态库是以 .a 为后缀的文件，共享库是以 .so为后缀的文件。&lt;/li&gt;
  &lt;li&gt;当程序与静态库连接时，库中目标文件所含的所有将被程序使用的函数的机器码被copy到最终的可执行文件中。这就会导致最终生成的可执行代码量相对变多，相当于编译器将代码补充完整了&lt;/li&gt;
  &lt;li&gt;与共享库连接的可执行文件只包含它需要的函数的引用表，而不是所有的函数代码，只有在程序执行时, 那些需要的函数代码才被拷贝到内存中。这样就使可执行文件比较小, 节省磁盘空间，更进一步，操作系统使用虚拟内存，使得一份共享库驻留在内存中被多个程序使用，也同时节约了内存。&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&quot;chapter-8&quot;&gt;chapter 8&lt;/h2&gt;
&lt;ul&gt;
  &lt;li&gt;异常控制流(Exceptional control flow, ECF)&lt;/li&gt;
  &lt;li&gt;遇到异常时 通过异常表这一跳转表，跳到专门处理这一异常的异常子程序&lt;/li&gt;
  &lt;li&gt;&lt;strong&gt;异常号&lt;/strong&gt; —— 唯一的非负整数&lt;/li&gt;
  &lt;li&gt;&lt;strong&gt;异常的四种类&lt;/strong&gt;：1.中断(interrupt) 2.陷阱(trap) 3.故障(fault) 4. 终止(abort)
&lt;img src=&quot;http://o6gcipdzi.bkt.clouddn.com/%E5%BC%82%E5%B8%B8.png&quot; alt=&quot;image&quot; /&gt;&lt;/li&gt;
  &lt;li&gt;中断的步骤：
    &lt;ol&gt;
      &lt;li&gt;将处理器的中断引脚置高，然后将异常号放到系统总线中&lt;/li&gt;
      &lt;li&gt;处理器检测到中断引脚为高，从系统总线总读取异常号&lt;/li&gt;
      &lt;li&gt;按照异常号调用特定的异常中断子程序，当处理程序返回时，将控制权交付给下一条指令（原来命令的下一条指令）&lt;/li&gt;
    &lt;/ol&gt;
  &lt;/li&gt;
  &lt;li&gt;&lt;strong&gt;陷阱&lt;/strong&gt;：syscall n 这条指令会导致转到一个异常处理程序的陷阱 用户态-&amp;gt;内核态&lt;/li&gt;
  &lt;li&gt;&lt;strong&gt;故障&lt;/strong&gt;：由错误引起，可被修正。典型例子：缺页异常 处理完后返回重新处理&lt;/li&gt;
  &lt;li&gt;&lt;strong&gt;终止&lt;/strong&gt;：由不可恢复的致命错误引起,通常为硬件错误&lt;/li&gt;
  &lt;li&gt;linux的典型错误 一般保护故障（引用了未定义的存储空间、修改只读文件） 会报segmentation fault
    &lt;h3 id=&quot;进程&quot;&gt;进程&lt;/h3&gt;
    &lt;p&gt;进程给应用程序：&lt;/p&gt;
    &lt;ol&gt;
      &lt;li&gt;一个独立的逻辑控制流&lt;/li&gt;
      &lt;li&gt;一个私有的地址空间&lt;/li&gt;
    &lt;/ol&gt;
  &lt;/li&gt;
  &lt;li&gt;并发流(concurrent flow): 一个流在运行时间上与另外一个流重复&lt;/li&gt;
  &lt;li&gt;并发(concurrrency):多个流并发地执行&lt;/li&gt;
  &lt;li&gt;并行流失并发流的子集，两个流在不同的处理器或者不同的电脑上，就叫并行流&lt;/li&gt;
  &lt;li&gt;模式位(mode bit) 决定程序是运行在用户态还是内核态（模式位为1）&lt;/li&gt;
  &lt;li&gt;用户态-&amp;gt;内核态的转变是通过异常转换的&lt;/li&gt;
  &lt;li&gt;内核为每个进程维持一个上下文 上下文切换：1. 保存当前进程的上下文 2. 恢复之前被剥夺的进程的上下文 3. 将控制传递给这个新恢复的进程&lt;/li&gt;
  &lt;li&gt;调度(schedule)：内核选中一个新的进程运行&lt;/li&gt;
  &lt;li&gt;错误处理包装函数：一般首字母大写，含有错误处理的机制&lt;/li&gt;
&lt;/ul&gt;

&lt;h4 id=&quot;进程控制&quot;&gt;进程控制&lt;/h4&gt;
&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;#include &amp;lt;sys/types.h&amp;gt;
#include &amp;lt;unisted.h&amp;gt;

pid_t getpid(void); //获取进程id
pid_t getppid(void); //获取父进程id
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;
&lt;ul&gt;
  &lt;li&gt;&lt;strong&gt;进程的三种状态&lt;/strong&gt; 运行(在cpu运行或者等待调度) 挂起(不会被调度 收到挂起信号 等待继续调度信号) 终止(1.收到信号说我是终止进程 2.从main函数返回 3.调用exit函数)&lt;/li&gt;
  &lt;li&gt;父进程创建子进程的时候，子进程几乎与父进程一样，除了pid，子i进程可以读写任何一个在父进程里面打开的文件。&lt;/li&gt;
  &lt;li&gt;fork 返回两次 对父（返回子进程的pid）子（返回0与区分是哪个进程，因为进程的pid是大于零的）&lt;/li&gt;
  &lt;li&gt;&lt;strong&gt;僵尸进程&lt;/strong&gt;: 当子进程因某种原因终止了时内核不是马上将其清除而是等待父进程回收（reap） 这种挂掉了但还没被回收的就叫做僵尸进程&lt;/li&gt;
  &lt;li&gt;waitpid(-1, &amp;amp;statue, 0) //等待子进程终结 返回pid -1则是所有都退出了&lt;/li&gt;
  &lt;li&gt;unsigned int sleep(unsigned int secs);&lt;/li&gt;
  &lt;li&gt;execve 函数打开一个新的进程来覆盖当前进程&lt;/li&gt;
  &lt;li&gt;程序总要运行在进程的上下文中
    &lt;h2 id=&quot;信号&quot;&gt;信号&lt;/h2&gt;
  &lt;/li&gt;
  &lt;li&gt;&lt;strong&gt;Unix 信号&lt;/strong&gt;：可允许进程中断另一个进程&lt;/li&gt;
  &lt;li&gt;example: ctrl+c 就是发送了键盘sigint中断信号&lt;/li&gt;
  &lt;li&gt;发信号的两个原因：1.内核检测到了一个系统信号 2.进程调用了kill指令&lt;/li&gt;
  &lt;li&gt;&lt;strong&gt;进程组概念&lt;/strong&gt; 父子进程在同一进程组 进程组可以被改变
    &lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;void getgpid(void);
void setgpid(void);
&lt;/code&gt;&lt;/pre&gt;
    &lt;/div&gt;
  &lt;/li&gt;
  &lt;li&gt;发送信号 例子：
    &lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;kill -9 1514 // 发送信号9(SIGKILL) 到进程1514
函数原型 int kill(pid_t, pid, int sig);
&lt;/code&gt;&lt;/pre&gt;
    &lt;/div&gt;
  &lt;/li&gt;
  &lt;li&gt;shell 用job形容一条命令行产生的进程，在同一时间只能有一个前台进程或者多个后台进程 例如：
    &lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;ls | sort // 创建两个进程的进程组来完成一个前台进程
&lt;/code&gt;&lt;/pre&gt;
    &lt;/div&gt;
  &lt;/li&gt;
  &lt;li&gt;ctrl + c 键盘发送SIGINT 发送到前台进程终止前台作业&lt;/li&gt;
  &lt;li&gt;ctrl + z 发送SIGSTP 到前台进程停止(挂起)前台作业
    &lt;h5 id=&quot;ctrl-z和ctrl-c区别&quot;&gt;CTRL-Z和CTRL-C区别?&lt;/h5&gt;
    &lt;p&gt;回答:&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;CTRL-Z和CTRL-C都是中断命令,但是他们的作用却不一样.&lt;/li&gt;
  &lt;li&gt;CTRL-C是强制中断程序的执行,&lt;/li&gt;
  &lt;li&gt;而CTRL-Z的是将任务中断,但是此任务并没有结束,他仍然在进程中他只是维持挂起的状态,用户可以使用fg/bg操作继续前台或后台的任务,fg命令重新启动前台被中断的任务,bg命令把被中断的任务放在后台执行.&lt;/li&gt;
  &lt;li&gt;可用过signal函数改变信号的默认行为 但是SIGKILL SIGSTP 不能改变
&lt;img src=&quot;http://o6gcipdzi.bkt.clouddn.com/signal.png&quot; alt=&quot;image&quot; /&gt;&lt;/li&gt;
  &lt;li&gt;只有一个待处理的信号&lt;/li&gt;
  &lt;li&gt;利用sigprocmask来同步进程&lt;/li&gt;
  &lt;li&gt;setjump :保存当前的环境信息 一次调用多次返回 try catch 机制类似catch&lt;/li&gt;
  &lt;li&gt;longjump: 跳到setjump那个去，无返回 像throw出错误 然后被catch&lt;/li&gt;
  &lt;li&gt;操作进程的工具 ps top kill pmap /proc(一个虚拟的文件系统)&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&quot;chapter-9-虚拟存储器&quot;&gt;chapter 9 虚拟存储器&lt;/h2&gt;
&lt;ul&gt;
  &lt;li&gt;虚拟存储器是主存的抽象&lt;/li&gt;
  &lt;li&gt;为进程提供一个大、一致、私有的地址空间&lt;/li&gt;
  &lt;li&gt;主存被组织成一个M个连续的字节 每个字节都有自己独立的物理地址(physical adress PA)&lt;/li&gt;
  &lt;li&gt;使用物理地址寻址称为物理寻址&lt;/li&gt;
  &lt;li&gt;虚拟寻址(virtual adressing)：cpu通过虚拟地址寻址 需转换成物理地址(地址翻译) 通过存储器管理单元(memory management unit, MMU)&lt;/li&gt;
  &lt;li&gt;虚拟地址空间 物理地址空间&lt;/li&gt;
  &lt;li&gt;虚拟存储器分割成虚拟页 物理存储器分割成物理页 二者大小相同&lt;/li&gt;
  &lt;li&gt;虚拟页的三种状态：未分配的、缓存的、未缓存的&lt;/li&gt;
  &lt;li&gt;&lt;strong&gt;页表&lt;/strong&gt;：将虚拟页映射到物理页 每个虚拟页都在页表里面占有一个页表条目PTE 指向物理页&lt;/li&gt;
  &lt;li&gt;虚拟地址-&amp;gt;MMU-&amp;gt;页表索引-&amp;gt;物理地址&lt;/li&gt;
  &lt;li&gt;&lt;strong&gt;缺页&lt;/strong&gt;：DRAM缓存不命中,触发缺页异常,寻找替换页，并且判断替换页是否是干净的，否则写回磁盘中&lt;/li&gt;
  &lt;li&gt;按需页面调度(demand paging)：不命中了再去换入页面
    &lt;h4 id=&quot;tlbtranslation-lookaside-buffer翻译后备缓冲器&quot;&gt;TLB(Translation Lookaside Buffer)翻译后备缓冲器&lt;/h4&gt;
  &lt;/li&gt;
  &lt;li&gt;由于CPU首先接到的是由程序传来的虚拟内存地址，所以CPU必须先到物理内存中取页表，然后对应程序传来的虚拟页面号，在表里找到对应的物理页面 号，最后才能访问实际的物理内存地址，也就是说整个过程中CPU必须访问两次物理内存(实际上访问的次数更多)。因此，为了减少CPU访问物理内存的次 数，引入TLB。&lt;/li&gt;
  &lt;li&gt;程序通常会聚集在一个很小的工作集中，因此经常命中，当工作集大于物理储存器的时候，就会造成页面不停地换入换出，也即是颠簸(thrashing)&lt;/li&gt;
  &lt;li&gt;虚拟存储器可以用来保护存储器 在PTE上做功夫 加许可位即可 违反许可位则引发段错误&lt;/li&gt;
  &lt;li&gt;n位的虚拟地址分为两部分 p位的虚拟页面偏移(VPO) n-p位的虚拟页面号(VPN) 因为物理页和虚拟页是大小一样的 所以VPN也是一样的 VPO和VPN结合就可以找到物理地址&lt;/li&gt;
  &lt;li&gt;压缩页表的常用方法为使用层次结构的页表&lt;/li&gt;
  &lt;li&gt;当使用k层层次页表时，虚拟地址分为k个VPN和1个VPO&lt;/li&gt;
  &lt;li&gt;linux缺页异常处理 1) 虚拟地址是合法的吗？ 2) 试图进行的存储器访问是否合法 3) 合法的话就牺牲一个页 查看是否是脏的 然后再把页换进来 返回重新执行那条代码
    &lt;h4 id=&quot;动态存储器分配&quot;&gt;动态存储器分配&lt;/h4&gt;
  &lt;/li&gt;
  &lt;li&gt;动态存储器分配器维护着一个进程的虚拟存储器区域，也就是堆(heap)&lt;/li&gt;
  &lt;li&gt;每个进程维护着一个brk指针 指向堆顶&lt;/li&gt;
  &lt;li&gt;分配器将堆看作是一系列的块(block)来管理 每个块就是一系列的虚拟存储器片(已分配或者空闲， 已分配的保留状态直到被释放)&lt;/li&gt;
  &lt;li&gt;分配器有两种 1) 显示分配器(c语言里的malloc free) 2)隐式分配器(java 也称垃圾回收器)&lt;/li&gt;
  &lt;li&gt;malloc 是双字边界对齐 也就是说你申请5个字 它会给你6个字的空间 (字=4字节)&lt;/li&gt;
  &lt;li&gt;&lt;strong&gt;碎片:&lt;/strong&gt; 有空闲的分配器但是不能满足分配请求 分为内部碎片 外部碎片&lt;/li&gt;
  &lt;li&gt;&lt;em&gt;内部碎片:&lt;/em&gt; 就是因为已分配的比实际需要的要大&lt;/li&gt;
  &lt;li&gt;&lt;em&gt;外部碎片&lt;/em&gt;:总的未分配的空间满足 但是没有一个单独的空间可以满足需求&lt;/li&gt;
  &lt;li&gt;隐式空闲链表 表头存储块大小和空闲位 头部占1个字(4个字节)&lt;/li&gt;
  &lt;li&gt;&lt;strong&gt;放置策略&lt;/strong&gt;：分配器搜索空闲链表 1. 首次匹配(first fit):找到的第一个 2.下一次匹配(next fit):从上一个找到的位置开始搜索 3.最佳匹配(best fit):找到所有的空闲块 找最合适的空闲块&lt;/li&gt;
  &lt;li&gt;所有空闲块都不满足 1) 合并物理相邻的空闲块 2) 分配器向内核请求额外的堆存储器 插入到空闲列表中&lt;/li&gt;
  &lt;li&gt;&lt;strong&gt;假碎片:&lt;/strong&gt;许多可用的空闲块被切割成小的、不可用的空闲块，解决方法:coalescing(合并)&lt;/li&gt;
  &lt;li&gt;&lt;strong&gt;立即合并&lt;/strong&gt;：每个块释放的时候马上合并 有可能产生抖动 不停地切割合并&lt;/li&gt;
  &lt;li&gt;&lt;strong&gt;推迟合并&lt;/strong&gt;: 等到某个稍晚的时候合并 例如某个分配失败的时候 再去合并&lt;/li&gt;
  &lt;li&gt;&lt;strong&gt;边界标记&lt;/strong&gt;: 在footer处加一个头部的copy 与当前块头部相差一个字的地址 因此当前块可以访问到头部以查询是否可以合并
    &lt;h4 id=&quot;c语言经常出现的错误&quot;&gt;C语言经常出现的错误&lt;/h4&gt;
    &lt;ol&gt;
      &lt;li&gt;间接引用坏指针
        &lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;int val;
scanf(&quot;%d&quot;, val);
&lt;/code&gt;&lt;/pre&gt;
        &lt;/div&gt;
      &lt;/li&gt;
      &lt;li&gt;读未初始化的存储器
        &lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;int *y = (int *)malloc(sizeof(int) * N);
int i;
for (i = 0; i &amp;lt; N; i++)
  y[i] += 1;
&lt;/code&gt;&lt;/pre&gt;
        &lt;/div&gt;
        &lt;p&gt;应用calloc 或者memset 设置为0&lt;/p&gt;
      &lt;/li&gt;
      &lt;li&gt;栈缓冲区溢出
        &lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;char buf[64];
gets(buf); // 这就有溢出的可能了 可用fgets代替
&lt;/code&gt;&lt;/pre&gt;
        &lt;/div&gt;
      &lt;/li&gt;
    &lt;/ol&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&quot;chapter-10-unix-io&quot;&gt;Chapter 10 UNIX I/O&lt;/h2&gt;
&lt;ul&gt;
  &lt;li&gt;shell 为每个新开的进程有三个打开了的文件：标准输入(标识符:0) 标准输出(标识符:1) 标准错误(标识符:2)&lt;/li&gt;
&lt;/ul&gt;</content><author><name>Bigzhao</name></author><summary type="html">chapter 1 计算机组成的五大部件：运算器、控制器、存储器、输入设备、输出设备</summary></entry><entry><title type="html">mpi 学习笔记-持续更新</title><link href="http://localhost:4000/2017/01/10/mpi-node/" rel="alternate" type="text/html" title="mpi 学习笔记-持续更新" /><published>2017-01-10T20:00:00+08:00</published><updated>2017-01-10T20:00:00+08:00</updated><id>http://localhost:4000/2017/01/10/mpi-node</id><content type="html" xml:base="http://localhost:4000/2017/01/10/mpi-node/">&lt;ul&gt;
  &lt;li&gt;message passing model&lt;/li&gt;
  &lt;li&gt;the Message Passing Interface (MPI) - standard interface&lt;/li&gt;
  &lt;li&gt;MPI is only a definition for an interface&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;几个重要的概念&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;communicator： 由一系列进程组成，拥有沟通的能力&lt;/li&gt;
  &lt;li&gt;每个进程都有 rank 沟通交流靠秩 + tag（标记信息）&lt;/li&gt;
  &lt;li&gt;
    &lt;table&gt;
      &lt;tbody&gt;
        &lt;tr&gt;
          &lt;td&gt;point-to-point communications&lt;/td&gt;
          &lt;td&gt;collective communications&lt;/td&gt;
        &lt;/tr&gt;
      &lt;/tbody&gt;
    &lt;/table&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&quot;编程篇&quot;&gt;编程篇&lt;/h2&gt;

&lt;p&gt;假设有个.c 文件 mpi&lt;/p&gt;
&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;mpicc mpi_hello_world.c -o hello_world
mpirun -np 4 -f host_file hello_world //np 是processing的数量
                                      //host_file 记录着集群的信息
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;
&lt;p&gt;host_file&lt;/p&gt;
&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;Ailab1
Ailab2
Ailab3
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;
&lt;p&gt;如果不想平均分，想根据核数来
host_file&lt;/p&gt;
&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;Ailab1:2
Ailab2:2
Ailab3:2
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;
&lt;p&gt;即可 有限Ailab1的两核，用完了再下一个&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;Sending and receiving are the two foundational concepts of MPI.&lt;/li&gt;
  &lt;li&gt;MPI allows senders and receivers to also specify message IDs with the message (known as tags)
    &lt;h5 id=&quot;send-和-recive-的原型&quot;&gt;send 和 recive 的原型&lt;/h5&gt;
    &lt;p&gt;```c
MPI_Send(
  void* data,
  int count,    // 送出了这么多 exactly
  MPI_Datatype datatype,
  int destination,
  int tag,
  MPI_Comm communicator)&lt;/p&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;MPI_Recv(
    void* data,
    int count, // 最多接受这么多 at most
    MPI_Datatype datatype,
    int source,
    int tag,
    MPI_Comm communicator,
    MPI_Status* status)&lt;/p&gt;
&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;##### mpi datatype
| MPI datatype  | C equivalent         
| ------------- |:-------------:
|MPI_SHORT 	|short int
|MPI_INT 	|int
|MPI_LONG 	|long int|
|MPI_LONG_LONG 	|long long int
|MPI_UNSIGNED_CHAR 	|unsigned char
|MPI_UNSIGNED_SHORT 	|unsigned short int
|MPI_UNSIGNED 	|unsigned int
|MPI_UNSIGNED_LONG 	|unsigned long int
|MPI_UNSIGNED_LONG_LONG 	|unsigned long long int
|MPI_FLOAT 	|float
|MPI_DOUBLE 	|double
|MPI_LONG_DOUBLE |	long double
|MPI_BYTE 	|char

- 能够创建自己的own MPI datatypes


##### 动态传输
利用status
```c
    MPI_Status status;
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;
&lt;p&gt;接收的长度&lt;/p&gt;
&lt;div class=&quot;language-c highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;n&quot;&gt;MPI_Get_count&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;amp;&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;status&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;MPI_INT&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;&amp;amp;&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;number_amount&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;  
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;
&lt;div class=&quot;language-c highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;n&quot;&gt;MPI_Probe&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;
    &lt;span class=&quot;kt&quot;&gt;int&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;source&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt;
    &lt;span class=&quot;kt&quot;&gt;int&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;tag&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt;
    &lt;span class=&quot;n&quot;&gt;MPI_Comm&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;comm&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt;
    &lt;span class=&quot;n&quot;&gt;MPI_Status&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;*&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;status&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;
&lt;p&gt;像MPI_Recv 一样除了真实接收数据
动态接收数组&lt;/p&gt;
&lt;div class=&quot;language-c highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;    &lt;span class=&quot;n&quot;&gt;MPI_Probe&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;0&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;0&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;MPI_COMM_WORLD&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;&amp;amp;&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;status&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;

    &lt;span class=&quot;c1&quot;&gt;// When probe returns, the status object has the size and other
&lt;/span&gt;    &lt;span class=&quot;c1&quot;&gt;// attributes of the incoming message. Get the message size
&lt;/span&gt;    &lt;span class=&quot;n&quot;&gt;MPI_Get_count&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;amp;&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;status&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;MPI_INT&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;&amp;amp;&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;number_amount&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;

    &lt;span class=&quot;c1&quot;&gt;// Allocate a buffer to hold the incoming numbers
&lt;/span&gt;    &lt;span class=&quot;kt&quot;&gt;int&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;*&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;number_buf&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;kt&quot;&gt;int&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;*&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;malloc&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;k&quot;&gt;sizeof&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;kt&quot;&gt;int&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;*&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;number_amount&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;

    &lt;span class=&quot;c1&quot;&gt;// Now receive the message with the allocated buffer
&lt;/span&gt;    &lt;span class=&quot;n&quot;&gt;MPI_Recv&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;number_buf&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;number_amount&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;MPI_INT&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;0&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;0&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt;
             &lt;span class=&quot;n&quot;&gt;MPI_COMM_WORLD&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;MPI_STATUS_IGNORE&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;
&lt;ul&gt;
  &lt;li&gt;As an exercise, make a wrapper around MPI_Recv that uses MPI_Probe for any dynamic applications you might write. It makes the code look much nicer :-)&lt;/li&gt;
&lt;/ul&gt;

&lt;h5 id=&quot;注意死锁的发生&quot;&gt;注意死锁的发生&lt;/h5&gt;
&lt;ul&gt;
  &lt;li&gt;MPI_Send 要 receive 完之后才 return,如果大家都 send 那就死锁了，教程里解决死锁的办法是奇偶 rank 的执行顺序不同，奇的话是先收后发，偶的话是先发后收&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&quot;mpi-broadcast-and-collective-communication&quot;&gt;MPI Broadcast and Collective Communication&lt;/h3&gt;
&lt;ul&gt;
  &lt;li&gt;a synchronization point&lt;/li&gt;
  &lt;li&gt;用于同步的函数
    &lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;MPI_Barrier(MPI_Comm communicator)
&lt;/code&gt;&lt;/pre&gt;
    &lt;/div&gt;
    &lt;p&gt;&lt;img src=&quot;http://mpitutorial.com/tutorials/mpi-broadcast-and-collective-communication/barrier.png&quot; alt=&quot;image&quot; /&gt;&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;broadcast: one process sends the same data to all processes in a communicator.&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;img src=&quot;http://mpitutorial.com/tutorials/mpi-broadcast-and-collective-communication/broadcast_pattern.png&quot; alt=&quot;broadcast&quot; /&gt;&lt;/p&gt;
&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;MPI_Bcast(
    void* data,
    int count,
    MPI_Datatype datatype,
    int root,
    MPI_Comm communicator)
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;
&lt;p&gt;无论是 root 还是 receive 进程都需要调用MPI_Bcast 因为有变量指定了root
broadcast utilizes a similar tree broadcast algorithm&lt;/p&gt;
&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;MPI_Wtime(); // 返回时间戳
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;
&lt;ul&gt;
  &lt;li&gt;MPI_Scatter 与 MPI_Bcast 很像， 唯一不同点是 MPI_Bcast 传相同数据而 MPI_Scatter 传不同的数据给不同的进程&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;img src=&quot;http://mpitutorial.com/tutorials/mpi-scatter-gather-and-allgather/broadcastvsscatter.png&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;
&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;MPI_Scatter(
    void* send_data,
    int send_count,
    MPI_Datatype send_datatype,
    void* recv_data,
    int recv_count,
    MPI_Datatype recv_datatype,
    int root,
    MPI_Comm communicator)
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;ul&gt;
  &lt;li&gt;MPI_Gather
    &lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;MPI_Gather(
  void* send_data,
  int send_count,
  MPI_Datatype send_datatype,
  void* recv_data,
  int recv_count,
  MPI_Datatype recv_datatype,
  int root,
  MPI_Comm communicator)
&lt;/code&gt;&lt;/pre&gt;
    &lt;/div&gt;
    &lt;p&gt;&lt;img src=&quot;http://mpitutorial.com/tutorials/mpi-scatter-gather-and-allgather/gather.png&quot; alt=&quot;gather&quot; /&gt;&lt;/p&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;root 需要 receive buffer 其他的就传个 NULL 就可以&lt;/p&gt;

&lt;p&gt;recv_count parameter 是每个进程发送的数量&lt;/p&gt;
&lt;ul&gt;
  &lt;li&gt;参考代码
```cpp
if (world_rank == 0) {
rand_nums = create_rand_nums(elements_per_proc * world_size);
}&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;// Create a buffer that will hold a subset of the random numbers
float *sub_rand_nums = malloc(sizeof(float) * elements_per_proc);&lt;/p&gt;

&lt;p&gt;// Scatter the random numbers to all processes
MPI_Scatter(rand_nums, elements_per_proc, MPI_FLOAT, sub_rand_nums,
            elements_per_proc, MPI_FLOAT, 0, MPI_COMM_WORLD);&lt;/p&gt;

&lt;p&gt;// Compute the average of your subset
float sub_avg = compute_avg(sub_rand_nums, elements_per_proc);
// Gather all partial averages down to the root process
float *sub_avgs = NULL;
if (world_rank == 0) {
  sub_avgs = malloc(sizeof(float) * world_size);
}
MPI_Gather(&amp;amp;sub_avg, 1, MPI_FLOAT, sub_avgs, 1, MPI_FLOAT, 0,
           MPI_COMM_WORLD);&lt;/p&gt;

&lt;p&gt;// Compute the total average of all numbers.
if (world_rank == 0) {
  float avg = compute_avg(sub_avgs, world_size);
}&lt;/p&gt;
&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;
- many-to-many communication pattern
- MPI_Allgather

![allgather](http://mpitutorial.com/tutorials/mpi-scatter-gather-and-allgather/allgather.png)
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;
&lt;p&gt;MPI_Allgather(
    void* send_data,
    int send_count,
    MPI_Datatype send_datatype,
    void* recv_data,
    int recv_count,
    MPI_Datatype recv_datatype,
    MPI_Comm communicator)&lt;/p&gt;
&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;与上面相似的例程
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;
&lt;p&gt;// Gather all partial averages down to all the processes
float *sub_avgs = (float *)malloc(sizeof(float) * world_size);
MPI_Allgather(&amp;amp;sub_avg, 1, MPI_FLOAT, sub_avgs, 1, MPI_FLOAT,
              MPI_COMM_WORLD);&lt;/p&gt;

&lt;p&gt;// Compute the total average of all numbers.
float avg = compute_avg(sub_avgs, world_size);&lt;/p&gt;
&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;- 获取 mpi_datatype_size 的函数
```cpp
 MPI_Type_size(datatype, &amp;amp;datatype_size); //the latter 是用来存储结果
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;
&lt;ul&gt;
  &lt;li&gt;reduce 是缩小算法规模的意思
    &lt;div class=&quot;language-cpp highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;n&quot;&gt;MPI_Reduce&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;
  &lt;span class=&quot;kt&quot;&gt;void&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;*&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;send_data&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt;
  &lt;span class=&quot;kt&quot;&gt;void&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;*&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;recv_data&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt;  &lt;span class=&quot;c1&quot;&gt;// 注意 recv_data 的大小是 sizeof(datatype) * count
&lt;/span&gt;  &lt;span class=&quot;kt&quot;&gt;int&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;count&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt;  
  &lt;span class=&quot;n&quot;&gt;MPI_Datatype&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;datatype&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt;
  &lt;span class=&quot;n&quot;&gt;MPI_Op&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;op&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt;
  &lt;span class=&quot;kt&quot;&gt;int&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;root&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt;
  &lt;span class=&quot;n&quot;&gt;MPI_Comm&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;communicator&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;
    &lt;/div&gt;
    &lt;p&gt;&lt;img src=&quot;http://mpitutorial.com/tutorials/mpi-reduce-and-allreduce/mpi_reduce_1.png&quot; alt=&quot;reduce&quot; /&gt;
reduce operation 操作符&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;MPI_MAX - Returns the maximum element.最大值&lt;/li&gt;
  &lt;li&gt;MPI_MIN - Returns the minimum element.最小值&lt;/li&gt;
  &lt;li&gt;MPI_SUM - Sums the elements.总和&lt;/li&gt;
  &lt;li&gt;MPI_PROD - Multiplies all elements.累乘&lt;/li&gt;
  &lt;li&gt;MPI_LAND - Performs a logical and across the elements.逻辑与&lt;/li&gt;
  &lt;li&gt;MPI_LOR - Performs a logical or across the elements.逻辑或&lt;/li&gt;
  &lt;li&gt;MPI_BAND - Performs a bitwise and across the bits of the elements.按位与&lt;/li&gt;
  &lt;li&gt;MPI_BOR - Performs a bitwise or across the bits of the elements.按位或&lt;/li&gt;
  &lt;li&gt;MPI_MAXLOC - Returns the maximum value and the rank of the process that owns it.最大值及进程的秩&lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;MPI_MINLOC - Returns the minimum value and the rank of the process that owns it.最小值及进程的秩&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;Allreduce 很明显 参数少了个 root
    &lt;div class=&quot;language-cpp highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;n&quot;&gt;MPI_Allreduce&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;
  &lt;span class=&quot;kt&quot;&gt;void&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;*&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;send_data&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt;
  &lt;span class=&quot;kt&quot;&gt;void&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;*&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;recv_data&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt;
  &lt;span class=&quot;kt&quot;&gt;int&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;count&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt;
  &lt;span class=&quot;n&quot;&gt;MPI_Datatype&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;datatype&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt;
  &lt;span class=&quot;n&quot;&gt;MPI_Op&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;op&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt;
  &lt;span class=&quot;n&quot;&gt;MPI_Comm&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;communicator&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;
    &lt;/div&gt;
    &lt;p&gt;&lt;img src=&quot;http://mpitutorial.com/tutorials/mpi-reduce-and-allreduce/mpi_allreduce_1.png&quot; alt=&quot;allreduce&quot; /&gt;&lt;/p&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;h5 id=&quot;总结一下-到目前为止-common-collectives-有&quot;&gt;总结一下 到目前为止 common collectives 有&lt;/h5&gt;
&lt;ul&gt;
  &lt;li&gt;[x] MPI_Bcast,&lt;/li&gt;
  &lt;li&gt;[x] MPI_Scatter&lt;/li&gt;
  &lt;li&gt;[x] MPI_Gather&lt;/li&gt;
  &lt;li&gt;[x] MPI_Reduce&lt;/li&gt;
&lt;/ul&gt;

&lt;h4 id=&quot;分割全局的通讯器communicator&quot;&gt;分割全局的通讯器COMMUNICATOR&lt;/h4&gt;
&lt;p&gt;就像下图一样
&lt;img src=&quot;http://mpitutorial.com/tutorials/introduction-to-groups-and-communicators/comm_split.png&quot; alt=&quot;split&quot; /&gt;
所需要的函数&lt;/p&gt;
&lt;div class=&quot;language-cpp highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;n&quot;&gt;MPI_Comm_split&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;
    &lt;span class=&quot;n&quot;&gt;MPI_Comm&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;comm&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt;  &lt;span class=&quot;c1&quot;&gt;//需要划分的communicator
&lt;/span&gt;    &lt;span class=&quot;kt&quot;&gt;int&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;color&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt;    &lt;span class=&quot;c1&quot;&gt;// 进程具有一样的 color 意味着是相同的 COMMUNICATOR
&lt;/span&gt;    &lt;span class=&quot;kt&quot;&gt;int&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;key&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt;      &lt;span class=&quot;c1&quot;&gt;// 这个值决定了进程在新的communicator里面的秩
&lt;/span&gt;    &lt;span class=&quot;n&quot;&gt;MPI_Comm&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;*&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;newcomm&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;  &lt;span class=&quot;c1&quot;&gt;//返回的新的communicator
&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;
&lt;p&gt;communicator 由ID 和 Group（set） 组成&lt;/p&gt;
&lt;div class=&quot;language-cpp highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;n&quot;&gt;MPI_Comm_group&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;
    &lt;span class=&quot;n&quot;&gt;MPI_Comm&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;comm&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt;
    &lt;span class=&quot;n&quot;&gt;MPI_Group&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;*&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;group&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;
&lt;p&gt;求两个组的并集&lt;/p&gt;
&lt;div class=&quot;language-cpp highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;n&quot;&gt;MPI_Group_union&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;
    &lt;span class=&quot;n&quot;&gt;MPI_Group&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;group1&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt;
    &lt;span class=&quot;n&quot;&gt;MPI_Group&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;group2&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt;
    &lt;span class=&quot;n&quot;&gt;MPI_Group&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;*&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;newgroup&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;
&lt;p&gt;求两个组的交集&lt;/p&gt;
&lt;div class=&quot;language-cpp highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;n&quot;&gt;MPI_Group_intersection&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;
    &lt;span class=&quot;n&quot;&gt;MPI_Group&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;group1&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt;
    &lt;span class=&quot;n&quot;&gt;MPI_Group&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;group2&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt;
    &lt;span class=&quot;n&quot;&gt;MPI_Group&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;*&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;newgroup&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;&lt;span class=&quot;err&quot;&gt;'&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;
&lt;p&gt;根据 rank 数组来提取出 group&lt;/p&gt;
&lt;div class=&quot;language-cpp highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;n&quot;&gt;MPI_Group_incl&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;
    &lt;span class=&quot;n&quot;&gt;MPI_Group&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;group&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt;
    &lt;span class=&quot;kt&quot;&gt;int&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;n&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt;
    &lt;span class=&quot;k&quot;&gt;const&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;int&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;ranks&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;[],&lt;/span&gt;
    &lt;span class=&quot;n&quot;&gt;MPI_Group&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;*&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;newgroup&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;
&lt;p&gt;根据 group 产生 communicator&lt;/p&gt;
&lt;div class=&quot;language-cpp highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;n&quot;&gt;MPI_Comm_create_group&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;
    &lt;span class=&quot;n&quot;&gt;MPI_Comm&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;comm&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt;
    &lt;span class=&quot;n&quot;&gt;MPI_Group&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;group&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt;
    &lt;span class=&quot;kt&quot;&gt;int&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;tag&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt;
    &lt;span class=&quot;n&quot;&gt;MPI_Comm&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;*&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;newcomm&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;
&lt;p&gt;下面是例程&lt;/p&gt;
&lt;div class=&quot;language-cpp highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;c1&quot;&gt;// Create a new communicator based on the group
&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;MPI_Comm&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;prime_comm&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
&lt;span class=&quot;n&quot;&gt;MPI_Comm_create_group&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;MPI_COMM_WORLD&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;prime_group&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;0&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;&amp;amp;&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;prime_comm&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;

&lt;span class=&quot;kt&quot;&gt;int&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;prime_rank&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;-&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;1&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;prime_size&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;-&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;1&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
&lt;span class=&quot;c1&quot;&gt;// If this rank isn't in the new communicator, it will be
// MPI_COMM_NULL. Using MPI_COMM_NULL for MPI_Comm_rank or
// MPI_Comm_size is erroneous
&lt;/span&gt;&lt;span class=&quot;k&quot;&gt;if&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;MPI_COMM_NULL&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;!=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;prime_comm&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
    &lt;span class=&quot;n&quot;&gt;MPI_Comm_rank&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;prime_comm&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;&amp;amp;&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;prime_rank&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;
    &lt;span class=&quot;n&quot;&gt;MPI_Comm_size&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;prime_comm&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;&amp;amp;&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;prime_size&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;
&lt;p&gt;判断 MPI_COMM_NULL 很重要 区分是否是是新 communicator 中的一员&lt;/p&gt;</content><author><name>Bigzhao</name></author><summary type="html">message passing model the Message Passing Interface (MPI) - standard interface MPI is only a definition for an interface</summary></entry><entry><title type="html">ubuntu12.04 源码安装 mpich2</title><link href="http://localhost:4000/2017/01/07/ubuntu12.04-%E6%BA%90%E7%A0%81%E5%AE%89%E8%A3%85-mpich2/" rel="alternate" type="text/html" title="ubuntu12.04 源码安装 mpich2" /><published>2017-01-07T20:00:00+08:00</published><updated>2017-01-07T20:00:00+08:00</updated><id>http://localhost:4000/2017/01/07/ubuntu12.04-%E6%BA%90%E7%A0%81%E5%AE%89%E8%A3%85-mpich2</id><content type="html" xml:base="http://localhost:4000/2017/01/07/ubuntu12.04-%E6%BA%90%E7%A0%81%E5%AE%89%E8%A3%85-mpich2/">&lt;h1 id=&quot;ubuntu1204-源码安装-mpich2&quot;&gt;ubuntu12.04 源码安装 mpich2&lt;/h1&gt;
&lt;ol&gt;
  &lt;li&gt;从 mpich &lt;a href=&quot;http://www.mpich.org/&quot;&gt;官网&lt;/a&gt; 上下载 mpich2 的源码包&lt;/li&gt;
  &lt;li&gt;解压并进入
    &lt;div class=&quot;language-bash highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;gp&quot;&gt;&amp;gt;&amp;gt;&amp;gt; &lt;/span&gt;tar -xzf mpich2-1.4.tar.gz
&lt;span class=&quot;gp&quot;&gt;&amp;gt;&amp;gt;&amp;gt; &lt;/span&gt;&lt;span class=&quot;nb&quot;&gt;cd &lt;/span&gt;mpich2-1.4
&lt;/code&gt;&lt;/pre&gt;
    &lt;/div&gt;
  &lt;/li&gt;
  &lt;li&gt;configure
    &lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;./configure --disable-fortran
&lt;/code&gt;&lt;/pre&gt;
    &lt;/div&gt;
  &lt;/li&gt;
  &lt;li&gt;安装
    &lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;make; sudo make install
&lt;/code&gt;&lt;/pre&gt;
    &lt;/div&gt;
  &lt;/li&gt;
  &lt;li&gt;我执行完以上步骤的时候编译通过，但是执行报错，关于动态链接库的错误
    &lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;share object lib 之类的 缺少 libmpi.so.12 之类的
&lt;/code&gt;&lt;/pre&gt;
    &lt;/div&gt;
  &lt;/li&gt;
  &lt;li&gt;解决办法-在共享的位置创建软链
    &lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;ln -s /usr/local/lib/libmpi.so libmpich.so.12
ln -s /usr/local/lib/libmpigc4.so libmpichcxx.so.12
ln -s /usr/local/lib/libmpigf.so libfmpich.so.12
ln -s /usr/local/lib/libmpigf.so libmpichf90.so.12
ln -s /usr/local/lib/libmpi.so libmpl.so.1
ln -s /usr/local/lib/libmpi.so libopa.so.1
&lt;/code&gt;&lt;/pre&gt;
    &lt;/div&gt;
  &lt;/li&gt;
&lt;/ol&gt;</content><author><name>Bigzhao</name></author><summary type="html">ubuntu12.04 源码安装 mpich2 从 mpich 官网 上下载 mpich2 的源码包 解压并进入 &amp;gt;&amp;gt;&amp;gt; tar -xzf mpich2-1.4.tar.gz &amp;gt;&amp;gt;&amp;gt; cd mpich2-1.4 configure ./configure --disable-fortran 安装 make; sudo make install 我执行完以上步骤的时候编译通过，但是执行报错，关于动态链接库的错误 share object lib 之类的 缺少 libmpi.so.12 之类的 解决办法-在共享的位置创建软链 ln -s /usr/local/lib/libmpi.so libmpich.so.12 ln -s /usr/local/lib/libmpigc4.so libmpichcxx.so.12 ln -s /usr/local/lib/libmpigf.so libfmpich.so.12 ln -s /usr/local/lib/libmpigf.so libmpichf90.so.12 ln -s /usr/local/lib/libmpi.so libmpl.so.1 ln -s /usr/local/lib/libmpi.so libopa.so.1</summary></entry><entry><title type="html">Piotr’s matlab toolbox 遇到的问题</title><link href="http://localhost:4000/2016/12/27/Piotr-matlab-toolbox/" rel="alternate" type="text/html" title="Piotr's matlab toolbox 遇到的问题" /><published>2016-12-27T20:00:00+08:00</published><updated>2016-12-27T20:00:00+08:00</updated><id>http://localhost:4000/2016/12/27/Piotr-matlab-toolbox</id><content type="html" xml:base="http://localhost:4000/2016/12/27/Piotr-matlab-toolbox/">&lt;h1 id=&quot;piotrs-matlab-toolbox-遇到的问题&quot;&gt;Piotr’s matlab toolbox 遇到的问题&lt;/h1&gt;

&lt;ul&gt;
  &lt;li&gt;背景：最近想使用计算机视觉大牛 piotor 的工具箱中的acfdetector。&lt;/li&gt;
  &lt;li&gt;下载:
    &lt;div class=&quot;language-bash highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;git clone https://github.com/pdollar/toolbox.git
&lt;/code&gt;&lt;/pre&gt;
    &lt;/div&gt;
  &lt;/li&gt;
  &lt;li&gt;在 matlab 中添加路径
    &lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&amp;gt;&amp;gt;&amp;gt; addpath(genpath('~\toolbox\'))  %这里是你的路径
&amp;gt;&amp;gt;&amp;gt; savepath
&lt;/code&gt;&lt;/pre&gt;
    &lt;/div&gt;
  &lt;/li&gt;
  &lt;li&gt;编译
    &lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&amp;gt;&amp;gt;&amp;gt; toolcompile
&lt;/code&gt;&lt;/pre&gt;
    &lt;/div&gt;
  &lt;/li&gt;
  &lt;li&gt;遇到的问题：我测试的代码是这样的
    &lt;div class=&quot;language-matlab highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;n&quot;&gt;I&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;=&lt;/span&gt;&lt;span class=&quot;nb&quot;&gt;imread&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;s1&quot;&gt;'example.png'&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;
&lt;span class=&quot;n&quot;&gt;t&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;=&lt;/span&gt;&lt;span class=&quot;nb&quot;&gt;load&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;s1&quot;&gt;'AcfCaltech+Detector.mat'&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;  
&lt;span class=&quot;n&quot;&gt;detector&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;=&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;t&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;detector&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;  
&lt;span class=&quot;nb&quot;&gt;tic&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
&lt;span class=&quot;n&quot;&gt;bbs&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;=&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;acfDetect&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;I&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;detector&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;
&lt;span class=&quot;nb&quot;&gt;toc&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
&lt;span class=&quot;nb&quot;&gt;figure&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;1&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;im&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;I&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;bbApply&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;s1&quot;&gt;'draw'&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;bbs&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;
    &lt;/div&gt;
    &lt;p&gt;会报错，错误如下:
```matlab
未定义与 ‘struct’ 类型的输入参数相对应的函数 ‘acfDetect1’。&lt;/p&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;出错 acfDetect&amp;gt;acfDetectImg (line 77)
    bb = acfDetect1(P.data{i},Ds{j}.clf,shrink,…&lt;/p&gt;

&lt;p&gt;出错 acfDetect (line 41)
if(~multiple), bbs=acfDetectImg(I,detector); else&lt;/p&gt;

&lt;p&gt;出错 test (line 6)
bbs=acfDetect(I,detector);
```
我估计是找不到 acfDetect1&lt;/p&gt;

&lt;p&gt;所以把原来在 \toolbox\detector\private 里面的 mex 后的 acfDetect1 文件拿出来 放到 \toolbox\detector 即可解决
&lt;img src=&quot;http://o6gcipdzi.bkt.clouddn.com/acfmatlaberror.png&quot; alt=&quot;example&quot; /&gt;&lt;/p&gt;</content><author><name>Bigzhao</name></author><summary type="html">Piotr’s matlab toolbox 遇到的问题</summary></entry><entry><title type="html">ubuntu server 16.04 挂载硬盘</title><link href="http://localhost:4000/2016/12/03/ubuntu-server-16.04-%E6%8C%82%E8%BD%BD%E7%A1%AC%E7%9B%98/" rel="alternate" type="text/html" title="ubuntu server 16.04 挂载硬盘" /><published>2016-12-03T20:00:00+08:00</published><updated>2016-12-03T20:00:00+08:00</updated><id>http://localhost:4000/2016/12/03/ubuntu-server-16.04-%E6%8C%82%E8%BD%BD%E7%A1%AC%E7%9B%98</id><content type="html" xml:base="http://localhost:4000/2016/12/03/ubuntu-server-16.04-%E6%8C%82%E8%BD%BD%E7%A1%AC%E7%9B%98/">&lt;p&gt;实验室最近新购了一批主机，带4个硬盘，但是进去只有1个正在使用。
检查发现系统上目前并没有挂载其余硬盘&lt;/p&gt;
&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;fdisk -l
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;
&lt;p&gt;尝试过直接挂载单数出现错误如下：&lt;/p&gt;
&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;wrong fs type, bad option, bad superblock
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;
&lt;p&gt;个人猜测是没有格式化，硬盘格式不对。
执行以下命令格式化 sdx:&lt;/p&gt;
&lt;div class=&quot;language-bash highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;sudo mkfs -t ext4 /dev/sdb
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;
&lt;p&gt;说明：&lt;/p&gt;
&lt;ul&gt;
  &lt;li&gt;-t ext4 表示将分区格式化成ext4文件系统类型。
科普模式开启：&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;++EXT4是第四代扩展文件系统（英语：Fourth extended filesystem，缩写为 ext4）是Linux系统下的日志文件系统，是ext3文件系统的后继版本。++&lt;/p&gt;

&lt;p&gt;注意：在格式 化完成后系统有如下提示：&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;This filesystem will be automatically checked every 28 mounts or
180 days, whichever comes first. Use tune2fs -c or -i to override.
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;
&lt;p&gt;表示系统为了保证文件系统的完整，每加载28次或每隔180天就要完整地检查文件系统，可以使用命令 tune2fs -c 或 tune2fs -i 来调整默认值 。&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;显示硬盘挂载情况
    &lt;div class=&quot;language-bash highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;sudo df -l
&lt;/code&gt;&lt;/pre&gt;
    &lt;/div&gt;
  &lt;/li&gt;
  &lt;li&gt;挂载
    &lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;sudo mount -t ext4 /dev/sdb /bigzhao
&lt;/code&gt;&lt;/pre&gt;
    &lt;/div&gt;
    &lt;p&gt;说明：&lt;/p&gt;
    &lt;ul&gt;
      &lt;li&gt;指定硬盘分区文件系统类型为ext4 ，同时将 /dev/sdb 分区挂载到目录 /bigzhao。&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;自动挂载
改变 /etc/fstab
    &lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;vim /etc/fstab
&lt;/code&gt;&lt;/pre&gt;
    &lt;/div&gt;
    &lt;p&gt;加入下面语句&lt;/p&gt;
    &lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;/dev/sdb  /home/tandazhao/sdb(这个是要挂载的目录) ext4 default 0 0
&lt;/code&gt;&lt;/pre&gt;
    &lt;/div&gt;
    &lt;p&gt;重启即可&lt;/p&gt;
  &lt;/li&gt;
&lt;/ol&gt;</content><author><name>Bigzhao</name></author><summary type="html">实验室最近新购了一批主机，带4个硬盘，但是进去只有1个正在使用。 检查发现系统上目前并没有挂载其余硬盘 fdisk -l 尝试过直接挂载单数出现错误如下： wrong fs type, bad option, bad superblock 个人猜测是没有格式化，硬盘格式不对。 执行以下命令格式化 sdx: sudo mkfs -t ext4 /dev/sdb 说明： -t ext4 表示将分区格式化成ext4文件系统类型。 科普模式开启：</summary></entry><entry><title type="html">ubuntu server 16.04 配置网络</title><link href="http://localhost:4000/2016/11/25/ubuntu-server-16.04-%E9%85%8D%E7%BD%AE%E7%BD%91%E7%BB%9C/" rel="alternate" type="text/html" title="ubuntu server 16.04 配置网络" /><published>2016-11-25T20:00:00+08:00</published><updated>2016-11-25T20:00:00+08:00</updated><id>http://localhost:4000/2016/11/25/ubuntu-server-16.04-%E9%85%8D%E7%BD%AE%E7%BD%91%E7%BB%9C</id><content type="html" xml:base="http://localhost:4000/2016/11/25/ubuntu-server-16.04-%E9%85%8D%E7%BD%AE%E7%BD%91%E7%BB%9C/">&lt;h1 id=&quot;ubuntu-server-1604-配置网络&quot;&gt;ubuntu server 16.04 配置网络&lt;/h1&gt;
&lt;p&gt;DELL PowerEdgeT630 装好系统后按传统方法配网络失败，折腾一番才知道是网卡名字不对路&lt;/p&gt;
&lt;ul&gt;
  &lt;li&gt;查看网卡具体信息(我的网卡名字是eno1，通常是eth0)
    &lt;div class=&quot;language-bash highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;ifconfig -a
&lt;/code&gt;&lt;/pre&gt;
    &lt;/div&gt;
  &lt;/li&gt;
  &lt;li&gt;下面这个命令没啥用 看网卡信息的
    &lt;div class=&quot;language-bash highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;lspci -v | grep eth
&lt;/code&gt;&lt;/pre&gt;
    &lt;/div&gt;
  &lt;/li&gt;
  &lt;li&gt;先看网卡有没有开
    &lt;div class=&quot;language-bash highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;ifconfig
&lt;/code&gt;&lt;/pre&gt;
    &lt;/div&gt;
  &lt;/li&gt;
  &lt;li&gt;没有开的话就开网络
    &lt;div class=&quot;language-bash highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;ifconfig eno1 up
&lt;/code&gt;&lt;/pre&gt;
    &lt;/div&gt;
    &lt;div class=&quot;language-bash highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;sudo vim /etc/init.d/interfaces
&lt;/code&gt;&lt;/pre&gt;
    &lt;/div&gt;
  &lt;/li&gt;
  &lt;li&gt;更改上面那个文件 添加所需要动态或者静态的信息 这里比较特殊 网卡名叫做eno1
    &lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;auto eno1
iface eno1 inet dhcp
&lt;/code&gt;&lt;/pre&gt;
    &lt;/div&gt;
  &lt;/li&gt;
  &lt;li&gt;重启网络
    &lt;div class=&quot;language-bash highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;sudo /etc/inid.d/networking restart
&lt;/code&gt;&lt;/pre&gt;
    &lt;/div&gt;
    &lt;p&gt;OK!&lt;/p&gt;
  &lt;/li&gt;
&lt;/ul&gt;</content><author><name>Bigzhao</name></author><summary type="html">ubuntu server 16.04 配置网络 DELL PowerEdgeT630 装好系统后按传统方法配网络失败，折腾一番才知道是网卡名字不对路 查看网卡具体信息(我的网卡名字是eno1，通常是eth0) ifconfig -a 下面这个命令没啥用 看网卡信息的 lspci -v | grep eth 先看网卡有没有开 ifconfig 没有开的话就开网络 ifconfig eno1 up sudo vim /etc/init.d/interfaces 更改上面那个文件 添加所需要动态或者静态的信息 这里比较特殊 网卡名叫做eno1 auto eno1 iface eno1 inet dhcp 重启网络 sudo /etc/inid.d/networking restart OK!</summary></entry><entry><title type="html">Ubuntu 16.04换apt源</title><link href="http://localhost:4000/2016/11/24/aliyun-ubuntu/" rel="alternate" type="text/html" title="Ubuntu 16.04换apt源" /><published>2016-11-24T20:00:00+08:00</published><updated>2016-11-24T20:00:00+08:00</updated><id>http://localhost:4000/2016/11/24/aliyun-ubuntu</id><content type="html" xml:base="http://localhost:4000/2016/11/24/aliyun-ubuntu/">&lt;div class=&quot;language-bash highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;nb&quot;&gt;cd &lt;/span&gt;etc/apt
cp source.list source.list.bak
sudo vim source.list
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;
&lt;p&gt;更改文件如下：&lt;/p&gt;
&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;deb http://mirrors.aliyun.com/ubuntu/ xenial main restricted universe multiverse
deb http://mirrors.aliyun.com/ubuntu/ xenial-security main restricted universe multiverse
deb http://mirrors.aliyun.com/ubuntu/ xenial-updates main restricted universe multiverse
deb http://mirrors.aliyun.com/ubuntu/ xenial-proposed main restricted universe multiverse
deb http://mirrors.aliyun.com/ubuntu/ xenial-backports main restricted universe multiverse
deb-src http://mirrors.aliyun.com/ubuntu/ xenial main restricted universe multiverse
deb-src http://mirrors.aliyun.com/ubuntu/ xenial-security main restricted universe multiverse
deb-src http://mirrors.aliyun.com/ubuntu/ xenial-updates main restricted universe multiverse
deb-src http://mirrors.aliyun.com/ubuntu/ xenial-proposed main restricted universe multiverse
deb-src http://mirrors.aliyun.com/ubuntu/ xenial-backports main restricted universe multiverse
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;
&lt;p&gt;保存完了之后&lt;/p&gt;
&lt;div class=&quot;language-bash highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;sudo apt update
sudo apt upgrade
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;</content><author><name>Bigzhao</name></author><summary type="html">cd etc/apt cp source.list source.list.bak sudo vim source.list 更改文件如下： deb http://mirrors.aliyun.com/ubuntu/ xenial main restricted universe multiverse deb http://mirrors.aliyun.com/ubuntu/ xenial-security main restricted universe multiverse deb http://mirrors.aliyun.com/ubuntu/ xenial-updates main restricted universe multiverse deb http://mirrors.aliyun.com/ubuntu/ xenial-proposed main restricted universe multiverse deb http://mirrors.aliyun.com/ubuntu/ xenial-backports main restricted universe multiverse deb-src http://mirrors.aliyun.com/ubuntu/ xenial main restricted universe multiverse deb-src http://mirrors.aliyun.com/ubuntu/ xenial-security main restricted universe multiverse deb-src http://mirrors.aliyun.com/ubuntu/ xenial-updates main restricted universe multiverse deb-src http://mirrors.aliyun.com/ubuntu/ xenial-proposed main restricted universe multiverse deb-src http://mirrors.aliyun.com/ubuntu/ xenial-backports main restricted universe multiverse 保存完了之后 sudo apt update sudo apt upgrade</summary></entry></feed>